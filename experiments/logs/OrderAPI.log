
🚀 Starting generation for app: OrderAPI (mode=hybrid)
2025/10/30 21:43:01 🔀 Starting HYBRID generation (rules + ML + validation)...
2025/10/30 21:43:01 📐 Step 1/3: Creating rule-based scaffold...
go: finding module for package github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/handlers
go: finding module for package github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/models
go: OrderAPI/internal/handlers imports
	github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/models: module github.com/eif-courses/hlabgen@latest found (v0.0.0-20251026202251-b89543cd5180), but does not contain package github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/models
go: OrderAPI/internal/handlers tested by
	OrderAPI/internal/handlers.test imports
	github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/handlers: module github.com/eif-courses/hlabgen@latest found (v0.0.0-20251026202251-b89543cd5180), but does not contain package github.com/eif-courses/hlabgen/experiments/out/OrderAPI/internal/handlers
✅ Rule-based scaffold created (structure only)
2025/10/30 21:43:07 🧠 Step 2/3: Using ML to enhance scaffold logic...
🤖 Trying model: gpt-4o
⏱️  Model call took 44.030960608s (model: gpt-4o, attempt: 1)
❌ JSON error: invalid character 'e' after object key:value pair
⚠️ Primary parse failed, retrying with JSON repair prompt...
🤖 Trying model: gpt-4o
⏱️  Model call took 22.620970493s (model: gpt-4o, attempt: 1)
🔁 Repair call took 22.620992351s
❌ JSON error: invalid character 'b' after object key:value pair
--- CLEANED JSON ---
[
  {
    "filename": "internal/models/order.go",
    "code": "package models\n\ntype Order struct {\n\tID       int         `json:\"id\"`\n\tCustomerID int      `json:\"customer_id\"`\n\tItems    []OrderItem `json:\"items\"`\n\tSubtotal float64    `json:\"subtotal\"`\n\tDiscount float64    `json:\"discount\"`\n\tTax      float64    `json:\"tax\"`\n\tTotal    float64    `json:\"total\"`\n\tStatus   string     `json:\"status\"`\n}\n\ntype OrderItem struct {\n\tID        int     `json:\"id\"`\n\tOrderID   int     `json:\"order_id\"`\n\tProductID int     `json:\"product_id\"`\n\tPrice     float64 `json:\"price\"`\n\tQuantity  int     `json:\"quantity\"`\n}\n\ntype Inventory struct {\n\tProductID int `json:\"product_id\"`\n\tStock     int `json:\"stock\"`\n}\n\ntype Customer struct {\n\tID        int  `json:\"id\"`\n\tIsPremium bool `json:\"is_premium\"`\n}\n"
  },
  {
    "filename": "internal/handlers/order.go",
    "code": "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"OrderAPI/internal/models\"\n\t\"github.com/gorilla/mux\"\n)\n\nvar orders []models.Order\nvar orderItems []models.OrderItem\nvar inventories []models.Inventory\nvar customers []models.Customer\nvar nextOrderID = 1\nvar nextOrderItemID = 1\n\nfunc CreateOrder(w http.ResponseWriter, r *http.Request) {\n\tvar order models.Order\n\tif r.Body == nil {\n\t\thttp.Error(w, \"missing body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(&order); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Validate inventory availability\n\tfor _, item := range order.Items {\n\t\tavailable := false\n\t\tfor _, inventory := range inventories {\n\t\t\tif inventory.ProductID == item.ProductID && inventory.Stock >= item.Quantity {\n\t\t\t\tavailable = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !available {\n\t\t\thttp.Error(w, \"insufficient inventory\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Calculate subtotal\n\torder.Subtotal = 0\n\tfor _, item := range order.Items {\n\t\torder.Subtotal += item.Price * float64(item.Quantity)\n\t}\n\n\t// Apply discounts\n\torder.Discount = 0\n\tfor _, customer := range customers {\n\t\tif customer.ID == order.CustomerID {\n\t\t\tif order.Subtotal > 100 && customer.IsPremium {\n\t\t\t\torder.Discount = order.Subtotal * 0.10\n\t\t\t} else if order.Subtotal > 200 {\n\t\t\t\torder.Discount = order.Subtotal * 0.05\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Calculate tax\n\torder.Tax = (order.Subtotal - order.Discount) * 0.08\n\n\t// Calculate total\n\torder.Total = order.Subtotal - order.Discount + order.Tax\n\n\t// Set order status\n\torder.Status = \"pending\"\n\n\t// Assign ID and append to orders\n\torder.ID = nextOrderID\n\tnextOrderID++\n\torders = append(orders, order)\n\n\t// Append order items\n\tfor i := range order.Items {\n\t\torder.Items[i].ID = nextOrderItemID\n\t\torder.Items[i].OrderID = order.ID\n\t\tnextOrderItemID++\n\t\torderItems = append(orderItems, order.Items[i])\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(order)\n}\n\nfunc GetOrders(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(orders)\n}\n\nfunc GetOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor _, order := range orders {\n\t\tif order.ID == id {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tjson.NewEncoder(w).Encode(order)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n\nfunc UpdateOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tvar updatedOrder models.Order\n\tif r.Body == nil {\n\t\thttp.Error(w, \"missing body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(&updatedOrder); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor i, order := range orders {\n\t\tif order.ID == id {\n\t\t\tupdatedOrder.ID = id\n\t\t\torders[i] = updatedOrder\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tjson.NewEncoder(w).Encode(updatedOrder)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n\nfunc DeleteOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor i, order := range orders {\n\t\tif order.ID == id {\n\t\t\torders = append(orders[:i], orders[i+1:]...)\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n"
  },
  {
    "filename": "internal/handlers/order_test.go",
    "code": "package handlers_test\n\nimport (\n\t"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/handlers\"\n\t\"OrderAPI/internal/models\"\n)\n\nfunc TestCreateOrder(t *testing.T) {\n\torder := models.Order{\n\t\tCustomerID: 1,\n\t\tItems: []models.OrderItem{\n\t\t\t{ProductID: 1, Price: 50, Quantity: 3},\n\t\t},\n\t}\n\tbody, _ := json.Marshal(order)\n\treq := httptest.NewRequest(\"POST\", \"/orders\", bytes.NewBuffer(body))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\thandlers.CreateOrder(w, req)\n\tif w.Code != http.StatusCreated {\n\t\tt.Errorf(\"Expected 201, got %d\", w.Code)\n\t}\n}\n\nfunc TestGetOrders(t *testing.T) {\n\treq := httptest.NewRequest(\"GET\", \"/orders\", nil)\n\tw := httptest.NewRecorder()\n\thandlers.GetOrders(w, req)\n\tif w.Code != http.StatusOK {\n\t\tt.Errorf(\"Expected 200, got %d\", w.Code)\n\t}\n}\n\nfunc TestGetOrder(t *testing.T) {\n\treq := httptest.NewRequest(\"GET\", \"/orders/1\", nil)\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\tw := httptest.NewRecorder()\n\thandlers.GetOrder(w, req)\n\tif w.Code != http.StatusOK && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 200 or 404, got %d\", w.Code)\n\t}\n}\n\nfunc TestUpdateOrder(t *testing.T) {\n\torder := models.Order{\n\t\tCustomerID: 1,\n\t\tItems: []models.OrderItem{\n\t\t\t{ProductID: 1, Price: 50, Quantity: 2},\n\t\t},\n\t}\n\tbody, _ := json.Marshal(order)\n\treq := httptest.NewRequest(\"PUT\", \"/orders/1\", bytes.NewBuffer(body))\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\thandlers.UpdateOrder(w, req)\n\tif w.Code != http.StatusOK && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 200 or 404, got %d\", w.Code)\n\t}\n}\n\nfunc TestDeleteOrder(t *testing.T) {\n\treq := httptest.NewRequest(\"DELETE\", \"/orders/1\", nil)\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\tw := httptest.NewRecorder()\n\thandlers.DeleteOrder(w, req)\n\tif w.Code != http.StatusNoContent && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 204 or 404, got %d\", w.Code)\n\t}\n}\n"
  },
  {
    "filename": "internal/routes/routes.go",
    "code": "package routes\n\nimport (\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/handlers\"\n)\n\nfunc Register(r *mux.Router) {\n\tr.HandleFunc(\"/orders\", handlers.CreateOrder).Methods(\"POST\")\n\tr.HandleFunc(\"/orders\", handlers.GetOrders).Methods(\"GET\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.GetOrder).Methods(\"GET\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.UpdateOrder).Methods(\"PUT\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.DeleteOrder).Methods(\"DELETE\")\n}\n"
  },
  {
    "filename": "cmd/main.go",
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/routes\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\troutes.Register(r)\n\tlog.Println(\"Server listening on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n"
  },
  {
    "filename": "tasks.md",
    "code": "# Lab Tasks - Advanced Features\n\n## Completed Implementation\n✅ All CRUD operations are fully implemented\n✅ Complete test suite for all handlers\n✅ Proper error handling and status codes\n\n## Optional Enhancements (Student Tasks)\n1. Add database persistence using SQLite or PostgreSQL\n2. Implement authentication and authorization middleware\n3. Add request validation using a validation library\n4. Implement pagination for GetBooks endpoint\n5. Add filtering and sorting capabilities\n6. Create OpenAPI/Swagger documentation\n7. Implement rate limiting middleware\n8. Add logging middleware for all requests\n"
  }
]
--- END ---
🧾 Saved ML metrics → experiments/OrderAPI/gen_metrics.json
2025/10/30 21:44:14 ⚠️  ML enhancement failed: failed to parse repaired output: json parse error: invalid character 'b' after object key:value pair
2025/10/30 21:44:14 🔁 Retrying with relaxed mode...
2025/10/30 21:44:14 🪄 Using relaxed ML generation mode (cleaning JSON output)...
🤖 Trying model: gpt-4o
⏱️  Model call took 37.50155693s (model: gpt-4o, attempt: 1)
❌ JSON error: invalid character 'e' after object key:value pair
⚠️ Primary parse failed, retrying with JSON repair prompt...
🤖 Trying model: gpt-4o
⏱️  Model call took 37.352788133s (model: gpt-4o, attempt: 1)
🔁 Repair call took 37.352801027s
❌ JSON error: invalid character 'b' after object key:value pair
--- CLEANED JSON ---
[
  {
    "filename": "internal/models/order.go",
    "code": "package models\n\ntype Order struct {\n\tID         int         `json:\"id\"`\n\tCustomerID int         `json:\"customer_id\"`\n\tItems      []OrderItem `json:\"items\"`\n\tSubtotal   float64     `json:\"subtotal\"`\n\tDiscount   float64     `json:\"discount\"`\n\tTax        float64     `json:\"tax\"`\n\tTotal      float64     `json:\"total\"`\n\tStatus     string      `json:\"status\"`\n}\n\ntype OrderItem struct {\n\tID        int     `json:\"id\"`\n\tOrderID   int     `json:\"order_id\"`\n\tProductID int     `json:\"product_id\"`\n\tPrice     float64 `json:\"price\"`\n\tQuantity  int     `json:\"quantity\"`\n}\n\ntype Customer struct {\n\tID        int    `json:\"id\"`\n\tIsPremium bool   `json:\"is_premium\"`\n}\n\ntype Product struct {\n\tID       int     `json:\"id\"`\n\tName     string  `json:\"name\"`\n\tPrice    float64 `json:\"price\"`\n\tQuantity int     `json:\"quantity\"`\n}\n"
  },
  {
    "filename": "internal/handlers/order.go",
    "code": "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/models\"\n)\n\nvar orders []models.Order\nvar nextOrderID = 1\nvar products = []models.Product{\n\t{ID: 1, Name: \"Product A\", Price: 50.0, Quantity: 10},\n\t{ID: 2, Name: \"Product B\", Price: 150.0, Quantity: 5},\n}\n\nfunc CreateOrder(w http.ResponseWriter, r *http.Request) {\n\tvar order models.Order\n\tif r.Body == nil {\n\t\thttp.Error(w, \"missing body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(&order); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Validate inventory\n\tfor _, item := range order.Items {\n\t\tproduct := findProductByID(item.ProductID)\n\t\tif product == nil || product.Quantity < item.Quantity {\n\t\t\thttp.Error(w, \"insufficient inventory\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Calculate subtotal\n\tsubtotal := 0.0\n\tfor _, item := range order.Items {\n\t\tsubtotal += item.Price * float64(item.Quantity)\n\t}\n\n\t// Apply discounts\n\tdiscount := 0.0\n\tcustomer := findCustomerByID(order.CustomerID)\n\tif subtotal > 100 && customer != nil && customer.IsPremium {\n\t\tdiscount = subtotal * 0.10\n\t} else if subtotal > 200 {\n\t\tdiscount = subtotal * 0.05\n\t}\n\n\t// Calculate tax\n\ttax := (subtotal - discount) * 0.08\n\n\t// Calculate total\n\ttotal := subtotal - discount + tax\n\n\torder.ID = nextOrderID\n\tnextOrderID++\n\torder.Subtotal = subtotal\n\torder.Discount = discount\n\torder.Tax = tax\n\torder.Total = total\n\torder.Status = \"pending\"\n\n\torders = append(orders, order)\n\n\tw.WriteHeader(http.StatusCreated)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(order)\n}\n\nfunc GetOrders(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(orders)\n}\n\nfunc GetOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor _, order := range orders {\n\t\tif order.ID == id {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tjson.NewEncoder(w).Encode(order)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n\nfunc UpdateOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tvar updatedOrder models.Order\n\tif r.Body == nil {\n\t\thttp.Error(w, \"missing body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tif err := json.NewDecoder(r.Body).Decode(&updatedOrder); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor i, order := range orders {\n\t\tif order.ID == id {\n\t\t\tupdatedOrder.ID = id\n\t\t\torders[i] = updatedOrder\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tjson.NewEncoder(w).Encode(updatedOrder)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n\nfunc DeleteOrder(w http.ResponseWriter, r *http.Request) {\n\tvars := mux.Vars(r)\n\tid, err := strconv.Atoi(vars[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tfor i, order := range orders {\n\t\tif order.ID == id {\n\t\t\torders = append(orders[:i], orders[i+1:]...)\n\t\t\tw.WriteHeader(http.StatusNoContent)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Order not found\", http.StatusNotFound)\n}\n\nfunc findProductByID(id int) *models.Product {\n\tfor _, product := range products {\n\t\tif product.ID == id {\n\t\t\treturn &product\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findCustomerByID(id int) *models.Customer {\n\t// Mock customer data\n\tcustomers := []models.Customer{\n\t\t{ID: 1, IsPremium: true},\n\t\t{ID: 2, IsPremium: false},\n\t}\n\tfor _, customer := range customers {\n\t\tif customer.ID == id {\n\t\t\treturn &customer\n\t\t}\n\t}\n\treturn nil\n}\n"
  },
  {
    "filename": "internal/handlers/order_test.go",
    "code": "package handlers_test\n\nimport (\n\t"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/handlers\"\n\t\"OrderAPI/internal/models\"\n)\n\nfunc TestCreateOrder(t *testing.T) {\n\torder := models.Order{\n\t\tCustomerID: 1,\n\t\tItems: []models.OrderItem{\n\t\t\t{ProductID: 1, Price: 50.0, Quantity: 2},\n\t\t},\n\t}\n\tbody, _ := json.Marshal(order)\n\treq := httptest.NewRequest(\"POST\", \"/orders\", bytes.NewBuffer(body))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\thandlers.CreateOrder(w, req)\n\tif w.Code != http.StatusCreated {\n\t\tt.Errorf(\"Expected 201, got %d\", w.Code)\n\t}\n}\n\nfunc TestGetOrders(t *testing.T) {\n\treq := httptest.NewRequest(\"GET\", \"/orders\", nil)\n\tw := httptest.NewRecorder()\n\thandlers.GetOrders(w, req)\n\tif w.Code != http.StatusOK {\n\t\tt.Errorf(\"Expected 200, got %d\", w.Code)\n\t}\n}\n\nfunc TestGetOrder(t *testing.T) {\n\treq := httptest.NewRequest(\"GET\", \"/orders/1\", nil)\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\tw := httptest.NewRecorder()\n\thandlers.GetOrder(w, req)\n\tif w.Code != http.StatusOK && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 200 or 404, got %d\", w.Code)\n\t}\n}\n\nfunc TestUpdateOrder(t *testing.T) {\n\torder := models.Order{\n\t\tCustomerID: 1,\n\t\tItems: []models.OrderItem{\n\t\t\t{ProductID: 1, Price: 50.0, Quantity: 3},\n\t\t},\n\t}\n\tbody, _ := json.Marshal(order)\n\treq := httptest.NewRequest(\"PUT\", \"/orders/1\", bytes.NewBuffer(body))\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\thandlers.UpdateOrder(w, req)\n\tif w.Code != http.StatusOK && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 200 or 404, got %d\", w.Code)\n\t}\n}\n\nfunc TestDeleteOrder(t *testing.T) {\n\treq := httptest.NewRequest(\"DELETE\", \"/orders/1\", nil)\n\treq = mux.SetURLVars(req, map[string]string{\"id\": \"1\"})\n\tw := httptest.NewRecorder()\n\thandlers.DeleteOrder(w, req)\n\tif w.Code != http.StatusNoContent && w.Code != http.StatusNotFound {\n\t\tt.Errorf(\"Expected 204 or 404, got %d\", w.Code)\n\t}\n}\n"
  },
  {
    "filename": "internal/routes/routes.go",
    "code": "package routes\n\nimport (\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/handlers\"\n)\n\nfunc Register(r *mux.Router) {\n\tr.HandleFunc(\"/orders\", handlers.CreateOrder).Methods(\"POST\")\n\tr.HandleFunc(\"/orders\", handlers.GetOrders).Methods(\"GET\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.GetOrder).Methods(\"GET\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.UpdateOrder).Methods(\"PUT\")\n\tr.HandleFunc(\"/orders/{id}\", handlers.DeleteOrder).Methods(\"DELETE\")\n}\n"
  },
  {
    "filename": "cmd/main.go",
    "code": "package main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"OrderAPI/internal/routes\"\n)\n\nfunc main() {\n\tr := mux.NewRouter()\n\troutes.Register(r)\n\tlog.Println(\"Server listening on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n"
  },
  {
    "filename": "tasks.md",
    "code": "# Lab Tasks - Advanced Features\n\n## Completed Implementation\n✅ All CRUD operations are fully implemented\n✅ Complete test suite for all handlers\n✅ Proper error handling and status codes\n\n## Optional Enhancements (Student Tasks)\n1. Add database persistence using SQLite or PostgreSQL\n2. Implement authentication and authorization middleware\n3. Add request validation using a validation library\n4. Implement pagination for GetOrders endpoint\n5. Add filtering and sorting capabilities\n6. Create OpenAPI/Swagger documentation\n7. Implement rate limiting middleware\n8. Add logging middleware for all requests\n"
  }
]
--- END ---
🧾 Saved ML metrics → experiments/OrderAPI/gen_metrics.json
2025/10/30 21:45:29 🧹 Cleaning malformed JSON output after error: failed to parse repaired output: json parse error: invalid character 'b' after object key:value pair
2025/10/30 21:45:29 🔁 Retrying ML generation in relaxed mode (second API call)...
🤖 Trying model: gpt-4o
⏱️  Model call took 35.929641141s (model: gpt-4o, attempt: 1)
✅ Parsed 6 files

📊 Generation Summary:
  • Duration: 35.929730729s
  • Primary Success: true
  • Repair Attempts: 0
  • Final Success: true
  • Error: 
✅ OrderAPI generation completed successfully
🧾 Saved ML metrics → experiments/OrderAPI/gen_metrics.json
2025/10/30 21:46:05 ✅ Relaxed ML generation succeeded.
🧾 Saved ML metrics → experiments/OrderAPI/gen_metrics_relaxed.json
2025/10/30 21:46:05 🔧 Step 3/3: Applying rule-based validation & fixes...
📝 Processing: internal/models/order.go
✅ Written: experiments/out/OrderAPI/internal/models/order.go
📝 Processing: internal/handlers/order.go
🔧 Fixed handler signature for CreateOrder
🔧 Fixed handler signature for GetOrders
🔧 Fixed handler signature for GetOrder
🔧 Fixed handler signature for UpdateOrder
🔧 Fixed handler signature for DeleteOrder
✅ Written: experiments/out/OrderAPI/internal/handlers/order.go
📝 Processing: internal/handlers/order_test.go
🔧 Fixed test signature for TestCreateOrder
🔧 Fixed test signature for TestGetOrders
🔧 Fixed test signature for TestGetOrder
🔧 Fixed test signature for TestUpdateOrder
🔧 Fixed test signature for TestDeleteOrder
✅ Auto-fixed test signatures in internal/handlers/order_test.go
✅ Written: experiments/out/OrderAPI/internal/handlers/order_test.go
📝 Processing: internal/routes/routes.go
🔧 Fixed Register function parameter
✅ Written: experiments/out/OrderAPI/internal/routes/routes.go
📝 Processing: cmd/main.go
✅ Written: experiments/out/OrderAPI/cmd/main.go
📝 Processing: tasks.md
⚠️  Syntax validation failed for tasks.md: temp.go:1:1: illegal character U+0023 '#'
🔧 Attempting additional fixes...
❌ Could not auto-fix syntax errors in tasks.md
✅ Written: experiments/out/OrderAPI/tasks.md

🔧 Total rule-based fixes applied: 11
🔧 Running rule-based auto-fix on ML-generated files...

🔧 Auto-fixing all files in: experiments/out/OrderAPI

📝 Fixing test function signatures...
  ✅ Fixed test signatures in order_test.go

📝 Fixing handler function signatures...

📝 Fixing routes Register function...

✅ Applied 1 auto-fixes
✅ Rule-based fixes applied successfully
🔧 Fixing parseID type mismatches...
🔍 Validating Go syntax...
✅ All generated files have valid Go syntax
2025/10/30 21:46:05 🔧 Detected module name: OrderAPI — fixing imports...
2025/10/30 21:46:05 ✅ No import fixes needed
🔧 Running go mod tidy...
✅ Dependencies tidied
✅ Hybrid generation completed (35.95s) - rules + ML synergy applied
🔧 Injected mux import → experiments/out/OrderAPI/internal/handlers/order.go
🔧 Verified mux dependency and tidied module
📁 Saved per-package coverage → experiments/out/OrderAPI/coverage.json
🧾 Added summary row (with ML metrics) → experiments/logs/coverage.csv

--- go test summary ---

--- experiments/out/OrderAPI/internal/handlers ---
=== RUN   TestCreateOrder
--- PASS: TestCreateOrder (0.00s)
=== RUN   TestGetOrders
--- PASS: TestGetOrders (0.00s)
=== RUN   TestGetOrder
--- PASS: TestGetOrder (0.00s)
=== RUN   TestUpdateOrder
--- PASS: TestUpdateOrder (0.00s)
=== RUN   TestDeleteOrder
--- PASS: TestDeleteOrder (0.00s)
PASS
coverage: 73.5% of statements
ok  	OrderAPI/internal/handlers	0.002s

------------------------
✅ Validation completed in 1.14s

📊 Summary for OrderAPI (mode: hybrid):
  • BuildSuccess = true
  • LintWarnings = 3
  • TestsPass    = true
  • Coverage     = 73.5%
  • Generation Duration = 35.951287295s
  • Repair Attempts = 0
  • Rule Fixes   = 12
🧾 Wrote 10 unique experiments to experiments/logs/summary.csv

🧾 Generating Markdown summary from JSON metrics...
📊 Markdown results saved → experiments/logs/results.md
✅ Summary successfully written to experiments/logs/results.md

✅ Experiment complete..
