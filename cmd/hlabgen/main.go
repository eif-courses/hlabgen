package main

import (
	"bufio"
	"flag"
	"fmt"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/eif-courses/hlabgen/internal/assemble"
	"github.com/eif-courses/hlabgen/internal/input"
	"github.com/eif-courses/hlabgen/internal/metrics"
	mlinternal "github.com/eif-courses/hlabgen/internal/ml"
	"github.com/eif-courses/hlabgen/internal/report"
	"github.com/eif-courses/hlabgen/internal/rules"
	"github.com/eif-courses/hlabgen/internal/validate"
	"github.com/joho/godotenv"
)

func main() {
	// --- 0) Load .env (optional) ---
	if err := godotenv.Load(); err != nil {
		log.Println("âš ï¸  .env not found (using system environment)")
	}

	// --- 1) CLI Flags ---
	in := flag.String("input", "experiments/input/LibraryAPI.json", "path to schema.json")
	mode := flag.String("mode", "hybrid", "rules|ml|hybrid")
	out := flag.String("out", "experiments/out/LibraryAPI", "output directory")
	flag.Parse()

	// --- 2) Load schema ---
	schema, err := input.Load(*in)
	if err != nil {
		log.Fatalf("âŒ Failed to load schema: %v", err)
	}

	fmt.Printf("\nðŸš€ Starting generation for app: %s (mode=%s)\n", schema.AppName, *mode)

	// --- 3) Rule-based scaffold ---
	if _, err := rules.Scaffold(*out, schema.AppName); err != nil {
		log.Fatalf("âŒ Scaffold failed: %v", err)
	}

	fmt.Println("âœ… Rule-based scaffold created")

	// --- 4) Generation based on mode ---
	var genMetrics mlinternal.GenerationMetrics
	var files []assemble.File

	if *mode == "ml" || *mode == "hybrid" {
		log.Println("ðŸ§  Starting ML-based code generation...")

		// âœ… FIX 3: Set mode before generation
		genMetrics.Mode = *mode

		// --- first try ---
		genFiles, metrics, err := mlinternal.Generate(mlinternal.Schema{
			AppName:    schema.AppName,
			Database:   schema.Database,
			APIPattern: schema.APIPattern,
			Difficulty: schema.Difficulty,
			Entities:   schema.Entities,
			Features:   schema.Features,
			Objectives: schema.Objectives,
		})

		genMetrics = metrics
		genMetrics.Mode = *mode // âœ… Ensure mode is preserved after ML call
		files = convertGenFiles(genFiles)

		if err != nil {
			log.Printf("âš ï¸  ML generation failed once: %v", err)
			log.Println("ðŸ” Retrying with relaxed mode...")

			// âœ… FIX 3: Set mode before relaxed generation
			genMetrics.Mode = *mode

			genFiles, metrics, err = mlinternal.GenerateRelaxed(mlinternal.Schema{
				AppName:    schema.AppName,
				Database:   schema.Database,
				APIPattern: schema.APIPattern,
				Difficulty: schema.Difficulty,
				Entities:   schema.Entities,
				Features:   schema.Features,
				Objectives: schema.Objectives,
			})

			genMetrics = metrics
			genMetrics.Mode = *mode // âœ… Ensure mode is preserved after relaxed call
			files = convertGenFiles(genFiles)
		}

		if err != nil {
			log.Printf("âŒ ML generation failed completely â€” falling back to rule-based only: %v", err)
			*mode = "rules" // Fallback to rules mode
		} else {
			if err := assemble.WriteMany(*out, files, &genMetrics); err != nil {
				log.Fatalf("âŒ Failed to write generated files: %v", err)
			}

			// ðŸ”§ Auto-fix all generated files
			fmt.Println("\nðŸ”§ Running auto-fix on generated files...")
			if err := assemble.FixAllGeneratedFiles(*out); err != nil {
				log.Printf("âš ï¸  Some auto-fixes failed: %v", err)
			} else {
				fmt.Println("âœ… Auto-fix completed successfully")
			}

			// ðŸ” Validate syntax immediately after generation
			fmt.Println("\nðŸ” Validating Go syntax...")
			syntaxErrors := validateGoSyntax(*out)
			if len(syntaxErrors) > 0 {
				fmt.Println("âš ï¸  Syntax errors found:")
				for _, err := range syntaxErrors {
					fmt.Printf("  - %s\n", err)
				}
				fmt.Println("ðŸ”§ Note: Auto-repair was attempted during file writing")
				fmt.Println("ðŸ’¡ Run 'go build ./...' in the output directory to see detailed errors")
			} else {
				fmt.Println("âœ… All generated files have valid Go syntax")
			}

			// ðŸ” Check if tests were generated
			testCount := 0
			for _, f := range files {
				if strings.HasSuffix(f.Filename, "_test.go") {
					testCount++
				}
			}
			if testCount == 0 {
				log.Println("âš ï¸  Warning: No test files were generated by ML")
			} else {
				log.Printf("âœ… Generated %d test file(s)", testCount)
			}

			// ðŸ”§ Fix imports based on go.mod
			fmt.Println("\nðŸ”§ Fixing import paths...")
			fixImportsToModule(*out)

			// ðŸ”§ Run go mod tidy
			fmt.Println("ðŸ”§ Running go mod tidy...")
			tidyCmd := exec.Command("go", "mod", "tidy")
			tidyCmd.Dir = *out
			tidyCmd.Stdout = os.Stdout
			tidyCmd.Stderr = os.Stderr
			if err := tidyCmd.Run(); err != nil {
				log.Printf("âš ï¸  go mod tidy failed: %v", err)
			} else {
				fmt.Println("âœ… Dependencies tidied")
			}

			// ðŸ” Final syntax check
			fmt.Println("\nðŸ” Final syntax validation after fixes...")
			finalErrors := validateGoSyntax(*out)
			if len(finalErrors) > 0 {
				fmt.Println("âš ï¸  Remaining syntax errors:")
				for _, err := range finalErrors {
					fmt.Printf("  - %s\n", err)
				}
			} else {
				fmt.Println("âœ… All syntax errors resolved")
			}

			fmt.Printf("âœ… ML generation completed (%.2fs)\n", genMetrics.Duration.Seconds())
		}
	}

	// âœ… Rules-only generation mode
	if *mode == "rules" {
		log.Println("âš™ï¸  Starting rules-based code generation...")

		genMetrics.StartTime = time.Now()
		genMetrics.Mode = *mode // âœ… FIX 3: Set mode for rules

		// Generate files for each entity
		for _, entity := range schema.Entities {
			// Model
			files = append(files, assemble.File{
				Filename: fmt.Sprintf("internal/models/%s.go", strings.ToLower(entity)),
				Content:  rules.GenerateModel(entity),
			})

			// Handler
			files = append(files, assemble.File{
				Filename: fmt.Sprintf("internal/handlers/%s.go", strings.ToLower(entity)),
				Content:  rules.GenerateHandler(entity, schema.AppName),
			})

			// Test
			files = append(files, assemble.File{
				Filename: fmt.Sprintf("internal/handlers/%s_test.go", strings.ToLower(entity)),
				Content:  rules.GenerateTest(entity, schema.AppName),
			})
		}

		// Routes
		files = append(files, assemble.File{
			Filename: "internal/routes/routes.go",
			Content:  rules.GenerateRoutes(schema.Entities, schema.AppName),
		})

		// Tasks markdown
		files = append(files, assemble.File{
			Filename: "tasks.md",
			Content:  rules.GenerateTasksMarkdown(schema.Entities),
		})

		genMetrics.EndTime = time.Now()
		genMetrics.Duration = genMetrics.EndTime.Sub(genMetrics.StartTime)
		genMetrics.PrimarySuccess = true
		genMetrics.FinalSuccess = true
		genMetrics.RuleFixes = len(files)

		// Write files (without ML-specific fixes)
		for _, f := range files {
			fullPath := filepath.Join(*out, f.Filename)
			if err := os.MkdirAll(filepath.Dir(fullPath), 0o755); err != nil {
				log.Fatalf("âŒ Failed to create directory %s: %v", filepath.Dir(fullPath), err)
			}

			if err := os.WriteFile(fullPath, []byte(f.Content), 0o644); err != nil {
				log.Fatalf("âŒ Failed to write file %s: %v", fullPath, err)
			}

			fmt.Printf("âœ… Written: %s\n", fullPath)
		}

		// Fix imports
		fmt.Println("\nðŸ”§ Fixing import paths...")
		fixImportsToModule(*out)

		// Run go mod tidy
		fmt.Println("ðŸ”§ Running go mod tidy...")
		tidyCmd := exec.Command("go", "mod", "tidy")
		tidyCmd.Dir = *out
		tidyCmd.Stdout = os.Stdout
		tidyCmd.Stderr = os.Stderr
		if err := tidyCmd.Run(); err != nil {
			log.Printf("âš ï¸  go mod tidy failed: %v", err)
		} else {
			fmt.Println("âœ… Dependencies tidied")
		}

		// Validate syntax
		fmt.Println("\nðŸ” Validating Go syntax...")
		syntaxErrors := validateGoSyntax(*out)
		if len(syntaxErrors) > 0 {
			fmt.Println("âš ï¸  Syntax errors found:")
			for _, err := range syntaxErrors {
				fmt.Printf("  - %s\n", err)
			}
		} else {
			fmt.Println("âœ… All generated files have valid Go syntax")
		}

		fmt.Printf("âœ… Rules-based generation completed (%.2fs)\n", genMetrics.Duration.Seconds())
		fmt.Printf("âœ… Generated %d files using rule-based templates\n", len(files))
	}

	// --- 4.5) Clean up any leftover fallback test files ---
	fallbackTestPath := filepath.Join(*out, "internal", "handlers", "book_test.go")
	if _, err := os.Stat(fallbackTestPath); err == nil {
		os.Remove(fallbackTestPath)
		log.Println("ðŸ§¹ Removed fallback test file")
	}

	// --- 5) Validate & Collect Build Metrics ---
	m, err := validate.Run(*out)
	if err != nil {
		log.Fatalf("âŒ Validation failed: %v", err)
	}

	fmt.Printf("\nðŸ“Š Summary for %s:\n", schema.AppName)
	fmt.Printf("  â€¢ BuildSuccess = %v\n", m.BuildSuccess)
	fmt.Printf("  â€¢ LintWarnings = %d\n", m.LintWarnings)
	fmt.Printf("  â€¢ TestsPass    = %v\n", m.TestsPass)
	fmt.Printf("  â€¢ Coverage     = %.1f%%\n", m.CoveragePct)
	fmt.Printf("  â€¢ Generation Duration = %v\n", genMetrics.Duration)
	fmt.Printf("  â€¢ Repair Attempts = %d\n", genMetrics.RepairAttempts)
	fmt.Printf("  â€¢ Rule Fixes   = %d\n", genMetrics.RuleFixes)
	fmt.Printf("  â€¢ Mode: %s\n", *mode)

	genMetrics.Mode = *mode // Ensure mode is set before saving metrics

	// --- 6) Save metrics ---
	_ = metrics.SaveResult(*out, m)
	_ = metrics.SaveMLMetrics(*out, genMetrics)
	_ = metrics.SaveCombinedMetrics(*out, m, genMetrics)

	// --- 6.5) Save experiment repeatability metadata ---
	metaPath := filepath.Join(*out, "experiment_info.txt")
	meta := fmt.Sprintf(
		"App: %s\nMode: %s\nTimestamp: %s\nOpenAI Model: %s\nBuildSuccess: %v\nTestsPass: %v\nCoverage: %.1f%%\nDuration: %v\nRepairAttempts: %d\nRuleFixes: %d\n",
		schema.AppName,
		*mode,
		time.Now().Format(time.RFC3339),
		getModelName(),
		m.BuildSuccess,
		m.TestsPass,
		m.CoveragePct,
		genMetrics.Duration,
		genMetrics.RepairAttempts,
		genMetrics.RuleFixes,
	)
	if err := os.WriteFile(metaPath, []byte(meta), 0o644); err != nil {
		log.Printf("âš ï¸  Failed to write experiment metadata: %v\n", err)
	}

	// --- 7) Aggregate all results across experiments ---
	summaryPath := "experiments/logs/summary.csv"
	_ = os.MkdirAll(filepath.Dir(summaryPath), 0o755)
	if err := metrics.AggregateToCSV("experiments/out", summaryPath); err != nil {
		log.Printf("âš ï¸  Failed to aggregate metrics: %v\n", err)
	}

	fmt.Println("\nðŸ§¾ Generating Markdown summary from JSON metrics...")
	if err := report.GenerateSummaryJSONReport(); err != nil {
		fmt.Println("âš ï¸ Failed to generate JSON summary:", err)
	} else {
		fmt.Println("âœ… Summary successfully written to experiments/logs/results.md")
	}

	fmt.Println("\nâœ… Experiment complete..")
}

// --- Helper: Convert []GenFile â†’ []assemble.File ---
func convertGenFiles(in []mlinternal.GenFile) []assemble.File {
	out := make([]assemble.File, len(in))
	for i, f := range in {
		out[i] = assemble.File{Filename: f.Filename, Content: f.Code}
	}
	return out
}

// --- Helper: Detect module name and fix imports automatically ---
func fixImportsToModule(projectDir string) {
	goMod := filepath.Join(projectDir, "go.mod")
	f, err := os.Open(goMod)
	if err != nil {
		log.Printf("âš ï¸  No go.mod found in %s (skipping import fix)", projectDir)
		return
	}
	defer f.Close()

	// Detect module name
	scanner := bufio.NewScanner(f)
	moduleName := ""
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			moduleName = strings.TrimSpace(strings.TrimPrefix(line, "module "))
			break
		}
	}
	if moduleName == "" {
		log.Printf("âš ï¸  Could not detect module name in go.mod (skipping import fix)")
		return
	}

	log.Printf("ðŸ”§ Detected module name: %s â€” fixing imports...", moduleName)

	fixCount := 0
	filepath.WalkDir(projectDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() {
			return nil
		}
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return nil
		}

		original := string(content)
		newContent := original

		// Fix all possible wrong import patterns
		wrongPatterns := []string{
			`"github.com/eif-courses/hlabgen/internal/`,
			`"github.com/yourusername/` + moduleName + `/internal/`,
			`"github.com/yourusername/` + moduleName + `/`,
			`"yourapp/`,
			`"your_project/`,
		}

		for _, wrongPattern := range wrongPatterns {
			correctPattern := fmt.Sprintf(`"%s/internal/`, moduleName)
			if strings.Contains(wrongPattern, "/internal/") {
				newContent = strings.ReplaceAll(newContent, wrongPattern, correctPattern)
			} else {
				newContent = strings.ReplaceAll(newContent, wrongPattern, fmt.Sprintf(`"%s/`, moduleName))
			}
		}

		// Write back if changed
		if newContent != original {
			err = os.WriteFile(path, []byte(newContent), 0o644)
			if err == nil {
				fixCount++
				relPath, _ := filepath.Rel(projectDir, path)
				log.Printf("  âœ… Updated imports in: %s", relPath)
			}
		}
		return nil
	})

	if fixCount > 0 {
		log.Printf("âœ… Fixed imports in %d file(s)", fixCount)
	} else {
		log.Println("âœ… No import fixes needed")
	}
}

// --- Helper: Get model name safely ---
func getModelName() string {
	model := os.Getenv("OPENAI_MODEL")
	if model == "" {
		return "gpt-4o-mini"
	}
	return model
}

// --- Helper: Validate Go syntax for all .go files ---
func validateGoSyntax(projectPath string) []string {
	var errors []string

	filepath.Walk(projectPath, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		_, parseErr := parser.ParseFile(fset, path, nil, parser.AllErrors)

		if parseErr != nil {
			relPath, _ := filepath.Rel(projectPath, path)
			errors = append(errors, fmt.Sprintf("%s: %v", relPath, parseErr))
		}

		return nil
	})

	return errors
}
