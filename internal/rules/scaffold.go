package rules

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// Detect local vs. GitHub mode
	useLocal := os.Getenv("HLABGEN_GITHUB_MODE") != "1"
	modulePath := appName
	if !useLocal {
		modulePath = fmt.Sprintf("github.com/eif-courses/%s", appName)
	}

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	// --- Auto-run `go mod tidy` to resolve dependencies ---
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = outDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	_ = cmd.Run() // ignore error for now, purely best-effort

	return files, nil
}

//
// ðŸ”§ Universal SafeDecode (no hardcoded entities)
//

// SafeDecode replaces any `json.NewDecoder(r.Body).Decode(&X)` line
// with a safe block that checks nil body and handles decode errors.
// It also ensures "net/http" and "encoding/json" are imported.
// It NEVER adds mux or extra write headers; it preserves the rest of the handler.
func SafeDecode(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	changed := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Match a full line with a decode call (no trailing semicolon block)
		// e.g., `json.NewDecoder(r.Body).Decode(&book)`
		if strings.Contains(trim, "json.NewDecoder(r.Body).Decode(&") && !strings.Contains(trim, ";") {
			// Detect var name between & and )
			varName := "data"
			if idx := strings.Index(trim, "Decode(&"); idx >= 0 {
				rest := trim[idx+len("Decode(&"):]
				if close := strings.Index(rest, ")"); close > 0 {
					candidate := rest[:close]
					// keep simple identifier only
					for i := range candidate {
						c := candidate[i]
						if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_') {
							candidate = candidate[:i]
							break
						}
					}
					if candidate != "" {
						varName = candidate
					}
				}
			}

			block := fmt.Sprintf(`if r.Body == nil {
		http.Error(w, "missing body", http.StatusBadRequest)
		return
	}
	if err := json.NewDecoder(r.Body).Decode(&%s); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}`, varName)

			out = append(out, block)
			changed = true
			continue
		}

		out = append(out, line)
	}

	fixed := strings.Join(out, "\n")

	// Ensure handlers NEVER import mux (strip it if present)
	if strings.Contains(fixed, "package handlers") && strings.Contains(fixed, `"github.com/gorilla/mux"`) {
		// remove single-line import and also possible grouped import member
		fixed = strings.ReplaceAll(fixed, "\n\t\"github.com/gorilla/mux\"", "")
		fixed = strings.ReplaceAll(fixed, "\"github.com/gorilla/mux\"\n", "")
	}

	// If we changed anything, ensure imports include net/http and encoding/json
	if changed {
		// add import block if missing
		if !strings.Contains(fixed, "\nimport (") && !strings.Contains(fixed, "\nimport \"") {
			// create a grouped import after package line
			fixed = strings.Replace(fixed, "package handlers", "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n", 1)
			return fixed
		}

		// ensure encoding/json present
		if !strings.Contains(fixed, `"encoding/json"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"encoding/json\"", 1)
		}
		// ensure net/http present
		if !strings.Contains(fixed, `"net/http"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http\"", 1)
		}
	}

	return fixed
}

// FixIDTypeMismatch ensures route path variables are converted to int when comparing with struct IDs.
func FixIDTypeMismatch(code string) string {
	if strings.Contains(code, "vars := mux.Vars(r)") && strings.Contains(code, "user.ID == id") {
		code = strings.ReplaceAll(code, "user.ID == id",
			"user.ID == parseID(id)")
		// Add parseID helper to file if missing
		if !strings.Contains(code, "func parseID(") {
			code += `

func parseID(s string) int {
	id, _ := strconv.Atoi(s)
	return id
}`
		}
		// Add strconv import if missing
		if !strings.Contains(code, `"strconv"`) {
			code = strings.Replace(code, "import (", "import (\n\t\"strconv\"", 1)
		}
	}
	return code
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixRegisterFunction normalizes any route registration function
// to a consistent name: func Register(r *mux.Router)
func FixRegisterFunction(code string) string {
	// Regex matches: func <something>Routes(
	re := regexp.MustCompile(`func\s+\w*Routes\s*\(`)
	if re.MatchString(code) {
		code = re.ReplaceAllString(code, "func Register(")
	}
	return code
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"github.com/gorilla/mux\"",
			1,
		)
	}
	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http/httptest\"",
			1,
		)
	}
	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http\"",
			1,
		)
	}
	return code
}

// FixTestBodies ensures that generated test files compile and pass by
// adding JSON bodies, correct HTTP methods, and fixing paths & duplicates.
func FixTestBodies(code string) string {
	lines := strings.Split(code, "\n")

	// Ensure correct package name for tests
	if strings.HasPrefix(strings.TrimSpace(lines[0]), "package ") &&
		!strings.HasPrefix(strings.TrimSpace(lines[0]), "package handlers_test") {
		lines[0] = "package handlers_test"
	}

	for i, line := range lines {
		if strings.HasPrefix(strings.TrimSpace(line), "func Test") &&
			strings.Contains(line, "(t *testing.T)") {

			testName := extractTestName(line)      // e.g. CreateBook, GetBooks
			_, entity := splitVerbEntity(testName) // e.g. Create / Book
			method := inferHTTPMethod(testName)    // POST/GET/PUT/DELETE
			resource := pluralizeIfNeeded(entity)  // books (not bookss)

			body := "{}"
			if method == "POST" || method == "PUT" {
				body = `{"id":1}`
			}

			// Build a full body for the test function
			testBody := fmt.Sprintf(`{
	body := strings.NewReader(%q)
	req, _ := http.NewRequest("%s", "/%s", body)
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()
	handlers.%s(rr, req)
	if rr.Code != http.StatusCreated && rr.Code != http.StatusOK && rr.Code != http.StatusNoContent {
		t.Errorf("handler returned wrong status code: got %%v", rr.Code)
	}
}`, body, method, resource, testName)

			// Replace ONLY the first "{" after the signature line with our body
			lines[i] = strings.Replace(line, "{", testBody, 1)
		}
	}

	fixed := strings.Join(lines, "\n")

	// Remove stub lines and extra braces
	fixed = fixDanglingClosers(fixed)

	// Ensure imports dynamically based on module name and then dedupe/sort
	fixed = ensureTestImports(fixed)

	// Final dedup for safety
	fixed = CleanDuplicateImports(fixed)

	return fixed
}

func ensureTestImports(code string) string {
	mod := detectModuleName()
	want := []string{
		"\"net/http\"",
		"\"net/http/httptest\"",
		"\"strings\"",
		fmt.Sprintf("\"%s/internal/handlers\"", mod),
	}
	// Make sure thereâ€™s an import block
	if !strings.Contains(code, "\nimport (") {
		// insert after package line
		lines := strings.Split(code, "\n")
		for i, l := range lines {
			if strings.HasPrefix(strings.TrimSpace(l), "package ") {
				block := "import (\n"
				for _, w := range want {
					block += "\t" + w + "\n"
				}
				block += ")\n"
				lines = append(lines[:i+1], append([]string{block}, lines[i+1:]...)...)
				return strings.Join(lines, "\n")
			}
		}
	} else {
		// Add missing imports into existing block
		for _, w := range want {
			if !strings.Contains(code, w) {
				code = strings.Replace(code, "import (", "import (\n\t"+w, 1)
			}
		}
	}
	return code
}

// detectModuleName tries to read module name from nearest go.mod file.
func detectModuleName() string {
	dir, _ := os.Getwd()
	for dir != "/" {
		modPath := filepath.Join(dir, "go.mod")
		data, err := os.ReadFile(modPath)
		if err == nil {
			for _, line := range strings.Split(string(data), "\n") {
				if strings.HasPrefix(line, "module ") {
					return strings.TrimSpace(strings.TrimPrefix(line, "module "))
				}
			}
		}
		dir = filepath.Dir(dir)
	}
	return "yourapp" // fallback
}

func extractTestName(line string) string {
	line = strings.TrimSpace(line)
	name := strings.TrimPrefix(line, "func Test")
	name = strings.Split(name, "(")[0]
	return strings.TrimSpace(name)
}

func inferHTTPMethod(name string) string {
	switch {
	case strings.HasPrefix(name, "Create"):
		return "POST"
	case strings.HasPrefix(name, "Update"):
		return "PUT"
	case strings.HasPrefix(name, "Delete"):
		return "DELETE"
	default:
		return "GET"
	}
}

// PlaceTestsWithHandlers ensures that generated test files (book_test.go, etc.)
// are stored next to their handler files in internal/handlers/
// and updated to use package handlers_test.
func PlaceTestsWithHandlers(filename, content string) (string, string) {
	if strings.HasPrefix(filename, "tests/") {
		base := filepath.Base(filename)
		filename = filepath.Join("internal", "handlers", base)

		// âœ… Force correct package
		lines := strings.Split(content, "\n")
		if len(lines) > 0 && strings.HasPrefix(lines[0], "package ") {
			lines[0] = "package handlers_test"
		}
		content = strings.Join(lines, "\n")

		// âœ… Detect module name dynamically
		module := detectModuleName()
		handlerImport := fmt.Sprintf("\"%s/internal/handlers\"", module)

		// âœ… Check whether imports exist
		hasImportBlock := strings.Contains(content, "import (")
		hasHandlers := strings.Contains(content, "/internal/handlers")

		// âœ… Add handlers import only once
		if !hasHandlers {
			if hasImportBlock {
				content = strings.Replace(content, "import (", "import (\n\t"+handlerImport, 1)
			} else {
				content = strings.Replace(content,
					"package handlers_test",
					"package handlers_test\n\nimport (\n\t"+handlerImport+"\n)\n",
					1,
				)
			}
		}

		// âœ… Normalize duplicates of handlers import
		lines = strings.Split(content, "\n")
		seen := make(map[string]bool)
		var clean []string
		for _, line := range lines {
			trim := strings.TrimSpace(line)

			// Skip duplicate handler imports
			if strings.Contains(trim, "/internal/handlers") {
				if seen["handlers"] {
					continue
				}
				seen["handlers"] = true
			}

			clean = append(clean, line)
		}
		content = strings.Join(clean, "\n")
	}
	return filename, content
}

// GenerateFallbackTests creates basic *_test.go files if ML fails.
func GenerateFallbackTests(outDir, appName string) error {
	tests := map[string]string{
		"book_test.go": `
package handlers_test

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"%s/internal/handlers"
)

func TestCreateBook(t *testing.T) {
	body := strings.NewReader(` + "`" + `{"id":1}` + "`" + `)
	req, _ := http.NewRequest("POST", "/books", body)
	rr := httptest.NewRecorder()
	handlers.CreateBook(rr, req)
	if rr.Code != http.StatusCreated {
		t.Errorf("expected 201, got %%v", rr.Code)
	}
}
`,
	}

	testDir := filepath.Join(outDir, "internal", "handlers")
	if err := os.MkdirAll(testDir, 0o755); err != nil {
		return err
	}

	for name, tpl := range tests {
		code := fmt.Sprintf(tpl, appName)
		code = CleanDuplicateImports(code)
		path := filepath.Join(testDir, name)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			if err := os.WriteFile(path, []byte(code), 0o644); err != nil {
				return err
			}
		}
	}

	return nil
}

// CleanDuplicateImports removes duplicate import lines (even if spacing or order differ)
// and ensures the file ends with balanced braces.
func CleanDuplicateImports(code string) string {
	lines := strings.Split(code, "\n")
	seen := make(map[string]bool)
	var out []string
	importBlock := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// detect start/end of import block
		if strings.HasPrefix(trim, "import (") {
			importBlock = true
			out = append(out, line)
			continue
		}
		if importBlock && strings.HasPrefix(trim, ")") {
			importBlock = false
			out = append(out, line)
			continue
		}

		// skip duplicate imports (normalize spacing and path)
		if importBlock && strings.HasPrefix(trim, `"`) {
			normalized := strings.ReplaceAll(trim, "\t", "")
			normalized = strings.ReplaceAll(normalized, " ", "")
			normalized = strings.Trim(normalized, `"`)
			if seen[normalized] {
				continue
			}
			seen[normalized] = true
		}

		out = append(out, line)
	}

	code = strings.Join(out, "\n")

	// âœ… Ensure exactly one closing brace at EOF if braces are unbalanced
	openCount := strings.Count(code, "{")
	closeCount := strings.Count(code, "}")
	if openCount > closeCount {
		code += "\n}"
	}

	return code
}

// fixDanglingClosers removes duplicate trailing braces and stub lines.
func fixDanglingClosers(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	var prev string
	for _, l := range lines {
		trim := strings.TrimSpace(l)
		// drop stub lines
		if trim == "// Implementation here" {
			continue
		}
		// collapse consecutive closing braces
		if trim == "}" && strings.TrimSpace(prev) == "}" {
			// skip this one
			continue
		}
		out = append(out, l)
		prev = l
	}
	return strings.Join(out, "\n")
}

// splitVerbEntity extracts the testing verb (Create/Get/Update/Delete) and the entity name
// from a test name like "CreateBook", "GetBooks", etc.
func splitVerbEntity(name string) (verb, entity string) {
	name = strings.TrimSpace(name)
	parts := []string{"Create", "Get", "Update", "Delete"}
	for _, p := range parts {
		if strings.HasPrefix(name, p) {
			return p, strings.TrimPrefix(name, p)
		}
	}
	return "Get", name // default
}

func pluralizeIfNeeded(entity string) string {
	if entity == "" {
		return "items"
	}
	el := strings.ToLower(entity)
	// If it's already plural (ends with s), leave it
	if strings.HasSuffix(el, "s") {
		return el
	}
	return el + "s"
}
