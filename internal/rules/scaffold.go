package rules

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
		filepath.Join(outDir, "tests"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// detect local vs. github module mode
	useLocal := true
	if os.Getenv("HLABGEN_GITHUB_MODE") == "1" {
		useLocal = false
	}

	// module name and import root
	var modulePath string
	if useLocal {
		modulePath = appName
	} else {
		modulePath = fmt.Sprintf("github.com/eif-courses/%s", appName)
	}

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	return files, nil
}

// SafeDecode adds body nil-checks and Decode error handling for all handlers.
func SafeDecode(code string) string {
	targets := []string{"book", "user", "loan", "item", "entity"}

	for _, t := range targets {
		pattern := fmt.Sprintf(`json.NewDecoder\(r.Body\)\.Decode\(&%s\)`, t)
		replacement := fmt.Sprintf(`if r.Body == nil {
	http.Error(w, "missing body", http.StatusBadRequest)
	return
}
if err := json.NewDecoder(r.Body).Decode(&%s); err != nil {
	http.Error(w, err.Error(), http.StatusBadRequest)
	return
}`, t)

		re := regexp.MustCompile(pattern)
		code = re.ReplaceAllString(code, replacement)
	}

	return code
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	// Add mux import if using mux.NewRouter() but not imported yet
	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"github.com/gorilla/mux\"",
			1,
		)
	}

	// Optional: ensure http and httptest exist (good rule for completeness)
	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http/httptest\"",
			1,
		)
	}
	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http\"",
			1,
		)
	}

	return code
}
