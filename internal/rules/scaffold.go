package rules

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
		filepath.Join(outDir, "tests"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// Detect local vs. GitHub mode
	useLocal := os.Getenv("HLABGEN_GITHUB_MODE") != "1"
	modulePath := appName
	if !useLocal {
		modulePath = fmt.Sprintf("github.com/eif-courses/%s", appName)
	}

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	// --- Auto-run `go mod tidy` to resolve dependencies ---
	goModDir := outDir
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = goModDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	_ = cmd.Run() // ignore error for now, purely best-effort

	return files, nil
}

//
// ðŸ”§ Universal SafeDecode (no hardcoded entities)
//

// SafeDecode replaces any `json.NewDecoder(r.Body).Decode(&X)` line
// with a safe block that checks nil body and handles decode errors.
// It also ensures "net/http" and "encoding/json" are imported.
// It NEVER adds mux or extra write headers; it preserves the rest of the handler.
func SafeDecode(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	changed := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Match a full line with a decode call (no trailing semicolon block)
		// e.g., `json.NewDecoder(r.Body).Decode(&book)`
		if strings.Contains(trim, "json.NewDecoder(r.Body).Decode(&") && !strings.Contains(trim, ";") {
			// Detect var name between & and )
			varName := "data"
			if idx := strings.Index(trim, "Decode(&"); idx >= 0 {
				rest := trim[idx+len("Decode(&"):]
				if close := strings.Index(rest, ")"); close > 0 {
					candidate := rest[:close]
					// keep simple identifier only
					for i := range candidate {
						c := candidate[i]
						if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_') {
							candidate = candidate[:i]
							break
						}
					}
					if candidate != "" {
						varName = candidate
					}
				}
			}

			block := fmt.Sprintf(`if r.Body == nil {
		http.Error(w, "missing body", http.StatusBadRequest)
		return
	}
	if err := json.NewDecoder(r.Body).Decode(&%s); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}`, varName)

			out = append(out, block)
			changed = true
			continue
		}

		out = append(out, line)
	}

	fixed := strings.Join(out, "\n")

	// Ensure handlers NEVER import mux (strip it if present)
	if strings.Contains(fixed, "package handlers") && strings.Contains(fixed, `"github.com/gorilla/mux"`) {
		// remove single-line import and also possible grouped import member
		fixed = strings.ReplaceAll(fixed, "\n\t\"github.com/gorilla/mux\"", "")
		fixed = strings.ReplaceAll(fixed, "\"github.com/gorilla/mux\"\n", "")
	}

	// If we changed anything, ensure imports include net/http and encoding/json
	if changed {
		// add import block if missing
		if !strings.Contains(fixed, "\nimport (") && !strings.Contains(fixed, "\nimport \"") {
			// create a grouped import after package line
			fixed = strings.Replace(fixed, "package handlers", "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n", 1)
			return fixed
		}

		// ensure encoding/json present
		if !strings.Contains(fixed, `"encoding/json"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"encoding/json\"", 1)
		}
		// ensure net/http present
		if !strings.Contains(fixed, `"net/http"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http\"", 1)
		}
	}

	return fixed
}

// FixIDTypeMismatch ensures route path variables are converted to int when comparing with struct IDs.
func FixIDTypeMismatch(code string) string {
	if strings.Contains(code, "vars := mux.Vars(r)") && strings.Contains(code, "user.ID == id") {
		code = strings.ReplaceAll(code, "user.ID == id",
			"user.ID == parseID(id)")
		// Add parseID helper to file if missing
		if !strings.Contains(code, "func parseID(") {
			code += `

func parseID(s string) int {
	id, _ := strconv.Atoi(s)
	return id
}`
		}
		// Add strconv import if missing
		if !strings.Contains(code, `"strconv"`) {
			code = strings.Replace(code, "import (", "import (\n\t\"strconv\"", 1)
		}
	}
	return code
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"github.com/gorilla/mux\"",
			1,
		)
	}
	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http/httptest\"",
			1,
		)
	}
	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http\"",
			1,
		)
	}
	return code
}

// FixTestBodies ensures POST/PUT requests in tests have valid JSON bodies.
func FixTestBodies(code string) string {
	if (strings.Contains(code, "http.NewRequest(\"POST\"") || strings.Contains(code, "http.NewRequest(\"PUT\"")) &&
		strings.Contains(code, "nil)") {

		// Insert a proper body declaration before the request creation
		code = strings.Replace(
			code,
			"req, err := http.NewRequest(",
			"body := strings.NewReader(`{\"id\":1}`)\n\treq, err := http.NewRequest(",
			1,
		)

		code = strings.Replace(code, "nil)", "body)", 1)

		// Add Content-Type header if missing
		if !strings.Contains(code, "req.Header.Set(\"Content-Type\"") {
			code = strings.Replace(code,
				"rr := httptest.NewRecorder()",
				"req.Header.Set(\"Content-Type\", \"application/json\")\n\trr := httptest.NewRecorder()",
				1)
		}

		// Add strings import if missing
		if !strings.Contains(code, `"strings"`) {
			code = strings.Replace(code, "import (", "import (\n\t\"strings\"", 1)
		}
	}

	return code
}

// PlaceTestsWithHandlers ensures that generated test files (book_test.go, etc.)
// are stored next to their handler files in internal/handlers/
// and updated to use package handlers_test.
func PlaceTestsWithHandlers(filename, content string) (string, string) {
	if strings.HasPrefix(filename, "tests/") {
		base := filepath.Base(filename)
		filename = filepath.Join("internal", "handlers", base)

		lines := strings.Split(content, "\n")
		if len(lines) > 0 && strings.HasPrefix(lines[0], "package ") {
			lines[0] = "package handlers_test"
		}
		content = strings.Join(lines, "\n")

		// âœ… Ensure "handlers" import is present only once
		if !strings.Contains(content, `"LibraryAPI/internal/handlers"`) {
			if strings.Contains(content, "import (") {
				content = strings.Replace(
					content,
					"import (",
					"import (\n\t\"LibraryAPI/internal/handlers\"",
					1,
				)
			} else {
				// If somehow import block missing entirely
				content = "import (\n\t\"LibraryAPI/internal/handlers\"\n)\n" + content
			}
		}

		// âœ… Remove duplicate handler imports if any (cleanup)
		lines = strings.Split(content, "\n")
		seen := make(map[string]bool)
		var clean []string
		for _, line := range lines {
			if strings.Contains(line, "\"LibraryAPI/internal/handlers\"") {
				if seen["handlers"] {
					continue
				}
				seen["handlers"] = true
			}
			clean = append(clean, line)
		}
		content = strings.Join(clean, "\n")
	}
	return filename, content
}
