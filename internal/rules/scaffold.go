package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// ============================================================================
// IMPROVED SCAFFOLD FOR CONSISTENT MODULE PATHS ACROSS ALL MODES
// ============================================================================

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// ImprovedScaffold creates a minimal working Go REST API project structure
// with CONSISTENT module naming across all generation modes
func ImprovedScaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// ‚úÖ CRITICAL FIX: Always use simple module name
	// This ensures consistency across ML, Hybrid, and Rules modes
	modulePath := normalizeModuleName(appName)
	fmt.Printf("üì¶ Using module name: %s\n", modulePath)

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`// Auto-generated scaffold for %s (%s)
package main

import (
	"log"
	"net/http"

	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, appName, time.Now().Format("2006-01-02 15:04:05"), modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	// ‚úÖ IMPORTANT: Keep go.mod simple with just the module name
	// Do NOT use full GitHub paths like:
	//   - github.com/eif-courses/hlabgen/experiments/out/AppName
	//   - github.com/yourusername/AppName
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, fmt.Errorf("failed to write file %s: %w", f.Name, err)
		}
		fmt.Printf("‚úÖ Created: %s\n", filepath.Base(f.Name))
	}

	// ‚úÖ Auto-run `go mod tidy` to resolve dependencies
	fmt.Println("üîß Running go mod tidy...")
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = outDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		fmt.Printf("‚ö†Ô∏è  go mod tidy had warnings (this is often OK): %v\n", err)
		// Don't fail here - mod tidy can warn about missing packages initially
	} else {
		fmt.Println("‚úÖ Dependencies tidied")
	}

	return files, nil
}

// ============================================================================
// CRITICAL: Module Name Normalization
// ============================================================================

// normalizeModuleName converts various path formats to a clean module name
// This is the KEY to consistency across all generation modes
func normalizeModuleName(appName string) string {
	// Step 1: Remove all path prefixes that might have been added
	normalized := appName

	// Remove GitHub paths
	normalized = strings.TrimPrefix(normalized, "github.com/eif-courses/hlabgen/experiments/out/")
	normalized = strings.TrimPrefix(normalized, "github.com/eif-courses/hlabgen/")
	normalized = strings.TrimPrefix(normalized, "github.com/yourusername/")
	normalized = strings.TrimPrefix(normalized, "github.com/")

	// Remove local paths
	normalized = strings.TrimPrefix(normalized, "experiments/out/")
	normalized = strings.TrimPrefix(normalized, "experiments/")

	// Remove any trailing slashes
	normalized = strings.TrimSuffix(normalized, "/")

	// Clean up whitespace
	normalized = strings.TrimSpace(normalized)

	// Step 2: Validation - ensure it's a valid Go module name
	if normalized == "" {
		return "unknown-app"
	}

	// Module names should be lowercase and simple
	normalized = strings.ToLower(normalized)

	// Replace spaces and underscores with hyphens
	normalized = strings.ReplaceAll(normalized, " ", "-")
	normalized = strings.ReplaceAll(normalized, "_", "-")

	fmt.Printf("  üìù Normalized '%s' ‚Üí '%s'\n", appName, normalized)

	return normalized
}

// ============================================================================
// HELPER: Module Detection for Import Path Fixing
// ============================================================================

// DetectModuleNameFromGoMod reads go.mod and extracts the module name
func DetectModuleNameFromGoMod(projectDir string) (string, error) {
	goModPath := filepath.Join(projectDir, "go.mod")
	data, err := os.ReadFile(goModPath)
	if err != nil {
		return "", fmt.Errorf("failed to read go.mod: %w", err)
	}

	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			moduleName := strings.TrimSpace(strings.TrimPrefix(line, "module "))
			return moduleName, nil
		}
	}

	return "", fmt.Errorf("module line not found in go.mod")
}

// ============================================================================
// INTEGRATION: Use in cmd/hlabgen/main.go
// ============================================================================

/*
INTEGRATION INSTRUCTIONS:

In cmd/hlabgen/main.go, replace the old scaffold call:

OLD:
	rules.Scaffold(outDir, schema.AppName)

NEW:
	ImprovedScaffold(outDir, schema.AppName)

And make sure to normalize the app name early in main():

	// At the very start of main(), after loading schema:
	schema.AppName = normalizeModuleName(schema.AppName)

Then ALL subsequent code will use the consistent, normalized module name.
*/

// ============================================================================
// VERIFICATION: Check that all imports match the module name
// ============================================================================

// VerifyImportConsistency checks that all imports use the correct module name
func VerifyImportConsistency(projectDir, expectedModuleName string) ([]string, error) {
	var issues []string

	err := filepath.Walk(projectDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		data, err := os.ReadFile(path)
		if err != nil {
			return nil
		}

		content := string(data)

		// Check for known wrong patterns
		wrongPatterns := []string{
			"github.com/eif-courses/hlabgen/experiments/out/",
			"github.com/yourusername/",
			"experiments/out/",
		}

		for _, pattern := range wrongPatterns {
			if strings.Contains(content, pattern) {
				relPath, _ := filepath.Rel(projectDir, path)
				issues = append(issues, fmt.Sprintf(
					"%s: contains wrong import pattern '%s' (should be '%s')",
					relPath, pattern, expectedModuleName,
				))
			}
		}

		// Check that internal imports use the correct module
		if strings.Contains(content, "/internal/") && !strings.Contains(content, expectedModuleName+"/internal/") {
			// This might be OK if it's just a comment or string
			// But if it's in an import statement, it's a problem
			lines := strings.Split(content, "\n")
			for i, line := range lines {
				if strings.Contains(line, "import") && strings.Contains(line, "/internal/") {
					if !strings.Contains(line, expectedModuleName) {
						relPath, _ := filepath.Rel(projectDir, path)
						issues = append(issues, fmt.Sprintf(
							"%s:%d: import statement uses wrong module name",
							relPath, i+1,
						))
					}
				}
			}
		}

		return nil
	})

	return issues, err
}

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

func example() {
	// Example 1: Normalize various input formats
	formats := []string{
		"ApprovalAPI",
		"github.com/eif-courses/hlabgen/experiments/out/ApprovalAPI",
		"experiments/out/ApprovalAPI",
		"github.com/yourusername/ApprovalAPI",
	}

	for _, f := range formats {
		normalized := normalizeModuleName(f)
		fmt.Printf("  %s ‚Üí %s\n", f, normalized)
	}

	// Example 2: Create scaffold
	outDir := "/tmp/test-app"
	files, err := ImprovedScaffold(outDir, "ApprovalAPI")
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return
	}
	fmt.Printf("Created %d files\n", len(files))

	// Example 3: Verify imports
	issues, err := VerifyImportConsistency(outDir, "ApprovalAPI")
	if err != nil {
		fmt.Printf("Verification error: %v\n", err)
		return
	}
	if len(issues) == 0 {
		fmt.Println("‚úÖ All imports are consistent!")
	} else {
		fmt.Println("‚ùå Found import inconsistencies:")
		for _, issue := range issues {
			fmt.Printf("  - %s\n", issue)
		}
	}
}
