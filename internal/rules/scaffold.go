package rules

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
		filepath.Join(outDir, "tests"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// Detect local vs. GitHub mode
	useLocal := os.Getenv("HLABGEN_GITHUB_MODE") != "1"
	modulePath := appName
	if !useLocal {
		modulePath = fmt.Sprintf("github.com/eif-courses/%s", appName)
	}

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	return files, nil
}

//
// ðŸ”§ Universal SafeDecode (no hardcoded entities)
//

// SafeDecode automatically injects JSON body validation and mock CRUD
// for any entity handler. Works for all future projects.
func SafeDecode(code string) string {
	// Add request body safety checks
	code = strings.ReplaceAll(code,
		"json.NewDecoder(r.Body).Decode(&",
		`if r.Body == nil {
	http.Error(w, "missing body", http.StatusBadRequest)
	return
}
if err := json.NewDecoder(r.Body).Decode(&`)

	// Detect which entity this handler works with
	entity := detectEntityName(code)
	if entity == "" {
		return code
	}

	lower := strings.ToLower(entity)
	storeDecl := fmt.Sprintf("var %ss []models.%s\n\n", lower, entity)
	code = strings.Replace(code, "package handlers", "package handlers\n\n"+storeDecl, 1)

	// Replace placeholder CRUD logic
	code = strings.ReplaceAll(code,
		fmt.Sprintf("// Logic to save %s to database", lower),
		fmt.Sprintf("%ss = append(%ss, %s)\nw.WriteHeader(http.StatusCreated)\njson.NewEncoder(w).Encode(%s)",
			lower, lower, lower, lower))

	code = strings.ReplaceAll(code,
		fmt.Sprintf("// Logic to fetch %ss from database", lower),
		fmt.Sprintf("w.WriteHeader(http.StatusOK)\njson.NewEncoder(w).Encode(%ss)", lower))

	return code
}

// detectEntityName tries to infer the entity (e.g., Book, Student, Loan) from models.<Entity>.
func detectEntityName(code string) string {
	if !strings.Contains(code, "models.") {
		return ""
	}
	start := strings.Index(code, "models.")
	if start == -1 {
		return ""
	}
	name := code[start+len("models."):]
	name = strings.TrimLeft(name, " *\t\n\r")
	for i, r := range name {
		if !(r >= 'A' && r <= 'Z' || r >= 'a' && r <= 'z') {
			return name[:i]
		}
	}
	return name
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"github.com/gorilla/mux\"",
			1,
		)
	}
	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http/httptest\"",
			1,
		)
	}
	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http\"",
			1,
		)
	}
	return code
}
