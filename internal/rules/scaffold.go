package rules

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// âœ… Automatically detect when to use GitHub-style module path.
	modulePath := detectModulePath(outDir, appName)

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	// âœ… Auto-run `go mod tidy` to resolve dependencies
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = outDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	_ = cmd.Run() // ignore error for now, purely best-effort

	return files, nil
}

// detectModulePath automatically switches between local and GitHub-style module paths.
func detectModulePath(outDir, appName string) string {
	// If generating inside a GitHub-like path, prefer full path.
	if strings.Contains(outDir, "github.com/") || strings.Contains(outDir, "eif-courses") {
		return fmt.Sprintf("github.com/eif-courses/%s", appName)
	}
	// Otherwise use local module (no prefix)
	return appName
}

//
// ðŸ”§ Universal SafeDecode (no hardcoded entities)
//

// SafeDecode replaces any `json.NewDecoder(r.Body).Decode(&X)` line
// with a safe block that checks nil body and handles decode errors.
// It also ensures "net/http" and "encoding/json" are imported.
func SafeDecode(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	changed := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		if strings.Contains(trim, "json.NewDecoder(r.Body).Decode(&") && !strings.Contains(trim, ";") {
			varName := "data"
			if idx := strings.Index(trim, "Decode(&"); idx >= 0 {
				rest := trim[idx+len("Decode(&"):]
				if close := strings.Index(rest, ")"); close > 0 {
					candidate := rest[:close]
					for i := range candidate {
						c := candidate[i]
						if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_') {
							candidate = candidate[:i]
							break
						}
					}
					if candidate != "" {
						varName = candidate
					}
				}
			}

			block := fmt.Sprintf(`if r.Body == nil {
		http.Error(w, "missing body", http.StatusBadRequest)
		return
	}
	if err := json.NewDecoder(r.Body).Decode(&%s); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}`, varName)

			out = append(out, block)
			changed = true
			continue
		}

		out = append(out, line)
	}

	fixed := strings.Join(out, "\n")

	// Remove mux import from handlers if present
	if strings.Contains(fixed, "package handlers") && strings.Contains(fixed, `"github.com/gorilla/mux"`) {
		fixed = strings.ReplaceAll(fixed, "\n\t\"github.com/gorilla/mux\"", "")
		fixed = strings.ReplaceAll(fixed, "\"github.com/gorilla/mux\"\n", "")
	}

	// Ensure imports include encoding/json and net/http if decode changed
	if changed {
		if !strings.Contains(fixed, "\nimport (") && !strings.Contains(fixed, "\nimport \"") {
			fixed = strings.Replace(fixed, "package handlers",
				"package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n", 1)
			return fixed
		}
		if !strings.Contains(fixed, `"encoding/json"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"encoding/json\"", 1)
		}
		if !strings.Contains(fixed, `"net/http"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http\"", 1)
		}
	}

	return fixed
}

// FixIDTypeMismatch ensures route path variables are converted to int when comparing with struct IDs.
func FixIDTypeMismatch(code string) string {
	if strings.Contains(code, "vars := mux.Vars(r)") && strings.Contains(code, "user.ID == id") {
		code = strings.ReplaceAll(code, "user.ID == id",
			"user.ID == parseID(id)")
		if !strings.Contains(code, "func parseID(") {
			code += `

func parseID(s string) int {
	id, _ := strconv.Atoi(s)
	return id
}`
		}
		if !strings.Contains(code, `"strconv"`) {
			code = strings.Replace(code, "import (", "import (\n\t\"strconv\"", 1)
		}
	}
	return code
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixRegisterFunction normalizes any route registration function
// to a consistent name: func Register(r *mux.Router)
func FixRegisterFunction(code string) string {
	re := regexp.MustCompile(`func\s+\w*Routes\s*\(`)
	if re.MatchString(code) {
		code = re.ReplaceAllString(code, "func Register(")
	}
	return code
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	// Add strings import if strings.NewReader is used
	if strings.Contains(code, "strings.NewReader") && !strings.Contains(code, `"strings"`) {
		if strings.Contains(code, "import (") {
			code = strings.Replace(code, "import (", "import (\n\t\"strings\"", 1)
		}
	}

	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		if strings.Contains(code, "import (") {
			code = strings.Replace(code, "import (", "import (\n\t\"github.com/gorilla/mux\"", 1)
		}
	}

	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		if strings.Contains(code, "import (") {
			code = strings.Replace(code, "import (", "import (\n\t\"net/http/httptest\"", 1)
		}
	}

	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		if strings.Contains(code, "import (") {
			code = strings.Replace(code, "import (", "import (\n\t\"net/http\"", 1)
		}
	}

	return code
}

// FixTestBodies ensures generated test files compile correctly with HTTP tests and proper JSON bodies.
func FixTestBodies(code string) string {
	lines := strings.Split(code, "\n")

	// âœ… Force correct package name
	if len(lines) > 0 && strings.HasPrefix(strings.TrimSpace(lines[0]), "package ") &&
		!strings.HasPrefix(strings.TrimSpace(lines[0]), "package handlers_test") {
		lines[0] = "package handlers_test"
	}

	var result []string
	i := 0

	for i < len(lines) {
		line := lines[i]
		trim := strings.TrimSpace(line)

		// Detect test function start
		if strings.HasPrefix(trim, "func Test") && strings.Contains(line, "(t *testing.T)") {
			testName := extractTestName(line)
			_, entity := splitVerbEntity(testName)
			method := inferHTTPMethod(testName)
			resource := pluralizeIfNeeded(entity)

			body := "{}"
			if method == "POST" || method == "PUT" {
				body = `{"id":1}`
			}

			// Generate complete test function with Test prefix
			testFunc := fmt.Sprintf(`func Test%s(t *testing.T) {
	body := strings.NewReader(%q)
	req, _ := http.NewRequest("%s", "/%s", body)
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()
	handlers.%s(rr, req)
	if rr.Code != http.StatusCreated && rr.Code != http.StatusOK && rr.Code != http.StatusNoContent {
		t.Errorf("handler returned wrong status code: got %%v", rr.Code)
	}
}`, testName, body, method, resource, testName)

			result = append(result, testFunc)

			// Skip until end of this test function
			i++
			braceCount := 1
			for i < len(lines) && braceCount > 0 {
				currentLine := strings.TrimSpace(lines[i])
				if currentLine == "}" && !strings.HasPrefix(lines[i], "\t") && !strings.HasPrefix(lines[i], " ") {
					braceCount--
					if braceCount == 0 {
						break
					}
				}
				i++
			}
		} else {
			result = append(result, line)
		}
		i++
	}

	fixed := strings.Join(result, "\n")

	// Ensure required imports are present
	if !strings.Contains(fixed, "import (") {
		// No import block at all, create one
		module := detectModuleName()
		importBlock := fmt.Sprintf(`

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"%s/internal/handlers"
)`, module)
		fixed = strings.Replace(fixed, "package handlers_test", "package handlers_test"+importBlock, 1)
	} else {
		// Add missing imports to existing block
		if strings.Contains(fixed, "strings.NewReader") && !strings.Contains(fixed, `"strings"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"strings\"", 1)
		}
		if strings.Contains(fixed, "http.NewRequest") && !strings.Contains(fixed, `"net/http"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http\"", 1)
		}
		if strings.Contains(fixed, "httptest.") && !strings.Contains(fixed, `"net/http/httptest"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http/httptest\"", 1)
		}
		if !strings.Contains(fixed, `"testing"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"testing\"", 1)
		}
	}

	// âœ… NEW: Remove unused imports from test files
	fixed = removeUnusedImports(fixed)

	fixed = CleanDuplicateImports(fixed)
	fixed = RemoveDuplicateHandlerImports(fixed)
	return fixed
}

// PlaceTestsWithHandlers ensures that generated test files are stored next to their handlers.
func PlaceTestsWithHandlers(filename, content string) (string, string) {
	if strings.HasPrefix(filename, "tests/") {
		base := filepath.Base(filename)
		filename = filepath.Join("internal", "handlers", base)

		// Change package name
		lines := strings.Split(content, "\n")
		if len(lines) > 0 && strings.HasPrefix(lines[0], "package ") {
			lines[0] = "package handlers_test"
		}
		content = strings.Join(lines, "\n")

		// Get module name
		module := detectModuleName()
		handlerImport := fmt.Sprintf(`"%s/internal/handlers"`, module)

		// Check if there's ALREADY an import block with handlers
		hasHandlerImport := strings.Contains(content, "/internal/handlers\"")

		// Only add if completely missing AND there's an import block
		if !hasHandlerImport && strings.Contains(content, "import (") {
			// Add to existing import block
			content = strings.Replace(content, "import (", "import (\n\t"+handlerImport, 1)
		} else if !hasHandlerImport && !strings.Contains(content, "import") {
			// Create new import block
			packageLine := "package handlers_test"
			replacement := packageLine + "\n\nimport (\n\t" + handlerImport + "\n)\n"
			content = strings.Replace(content, packageLine, replacement, 1)
		}

		// CRITICAL: Final aggressive cleanup
		content = RemoveAllDuplicateHandlerImports(content)
		content = CleanDuplicateImports(content)
	}
	return filename, content
}

// RemoveAllDuplicateHandlerImports - nuclear option, keeps only FIRST handler import
func RemoveAllDuplicateHandlerImports(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	handlerImportFound := false
	inImport := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		if strings.HasPrefix(trim, "import (") {
			inImport = true
			out = append(out, line)
			continue
		}

		if inImport && trim == ")" {
			inImport = false
			out = append(out, line)
			continue
		}

		// Inside import block - check for handler import
		if inImport && strings.Contains(trim, "/internal/handlers\"") {
			if !handlerImportFound {
				out = append(out, line)
				handlerImportFound = true
			}
			// Skip all subsequent handler imports
			continue
		}

		out = append(out, line)
	}

	return strings.Join(out, "\n")
}

// --- helpers used by test generation ---
func detectModuleName() string {
	dir, _ := os.Getwd()
	for dir != "/" {
		modPath := filepath.Join(dir, "go.mod")
		data, err := os.ReadFile(modPath)
		if err == nil {
			for _, line := range strings.Split(string(data), "\n") {
				if strings.HasPrefix(line, "module ") {
					return strings.TrimSpace(strings.TrimPrefix(line, "module "))
				}
			}
		}
		dir = filepath.Dir(dir)
	}
	return "yourapp"
}

func extractTestName(line string) string {
	line = strings.TrimSpace(line)
	name := strings.TrimPrefix(line, "func Test")
	name = strings.Split(name, "(")[0]
	return strings.TrimSpace(name)
}

func inferHTTPMethod(name string) string {
	switch {
	case strings.HasPrefix(name, "Create"):
		return "POST"
	case strings.HasPrefix(name, "Update"):
		return "PUT"
	case strings.HasPrefix(name, "Delete"):
		return "DELETE"
	default:
		return "GET"
	}
}

func splitVerbEntity(name string) (verb, entity string) {
	name = strings.TrimSpace(name)
	parts := []string{"Create", "Get", "Update", "Delete"}
	for _, p := range parts {
		if strings.HasPrefix(name, p) {
			return p, strings.TrimPrefix(name, p)
		}
	}
	return "Get", name
}

func pluralizeIfNeeded(entity string) string {
	if entity == "" {
		return "items"
	}
	el := strings.ToLower(entity)
	if strings.HasSuffix(el, "s") {
		return el
	}
	return el + "s"
}

// GenerateFallbackTests creates simple *_test.go files if test generation fails.
func GenerateFallbackTests(outDir, appName string) error {
	testTemplate := fmt.Sprintf(`package handlers_test

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"%s/internal/handlers"
)

func TestCreateBook(t *testing.T) {
	body := strings.NewReader("{\"id\":1}")
	req, _ := http.NewRequest("POST", "/books", body)
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()
	handlers.CreateBook(rr, req)
	if rr.Code != http.StatusCreated && rr.Code != http.StatusOK && rr.Code != http.StatusNoContent {
		t.Errorf("handler returned wrong status code: got %%v", rr.Code)
	}
}
`, appName)

	testDir := filepath.Join(outDir, "internal", "handlers")
	if err := os.MkdirAll(testDir, 0o755); err != nil {
		return err
	}

	testFile := filepath.Join(testDir, "book_test.go")
	if _, err := os.Stat(testFile); os.IsNotExist(err) {
		if err := os.WriteFile(testFile, []byte(testTemplate), 0o644); err != nil {
			return err
		}
	}

	return nil
}

// CleanDuplicateImports removes duplicate import lines and normalizes spacing
func CleanDuplicateImports(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	inImportBlock := false
	seenImports := make(map[string]struct{}) // Use struct{} instead of bool for memory efficiency

	for i := 0; i < len(lines); i++ {
		line := lines[i]
		trim := strings.TrimSpace(line)

		// Detect import block start
		if strings.HasPrefix(trim, "import (") {
			inImportBlock = true
			seenImports = make(map[string]struct{}) // Reset for this block
			out = append(out, line)
			continue
		}

		// Detect import block end
		if inImportBlock && trim == ")" {
			inImportBlock = false
			out = append(out, line)
			continue
		}

		// Process imports inside the block
		if inImportBlock {
			// Skip empty lines in import block
			if trim == "" {
				continue
			}

			// Extract the import path for comparison (normalize it)
			importKey := strings.TrimSpace(trim)

			// Check if we've seen this exact import before
			if _, exists := seenImports[importKey]; exists {
				// Skip this duplicate import
				continue
			}
			seenImports[importKey] = struct{}{}
			out = append(out, line)
			continue
		}

		// Not in import block
		out = append(out, line)
	}

	code = strings.Join(out, "\n")

	// âœ… Ensure balanced braces
	openCount := strings.Count(code, "{")
	closeCount := strings.Count(code, "}")
	if openCount > closeCount {
		code += strings.Repeat("\n}", openCount-closeCount)
	}

	return code
}

// RemoveDuplicateHandlerImports removes ALL duplicate handler imports
func RemoveDuplicateHandlerImports(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	inImportBlock := false
	handlerImportSeen := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Track import block
		if strings.HasPrefix(trim, "import (") {
			inImportBlock = true
			handlerImportSeen = false
			out = append(out, line)
			continue
		}

		if inImportBlock && trim == ")" {
			inImportBlock = false
			out = append(out, line)
			continue
		}

		// Inside import block - check for ANY handler import
		if inImportBlock && strings.Contains(trim, "/handlers\"") {
			if handlerImportSeen {
				// Skip this duplicate
				continue
			}
			handlerImportSeen = true
			out = append(out, line)
			continue
		}

		out = append(out, line)
	}

	return strings.Join(out, "\n")
}

// removeUnusedImports strips imports that aren't used in the code (safe version)
// removeUnusedImports strips imports that aren't used in the code (safe version)
func removeUnusedImports(code string) string {
	lines := strings.Split(code, "\n")
	var result []string
	inImportBlock := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Track import block start
		if strings.HasPrefix(trim, "import (") {
			inImportBlock = true
			result = append(result, line)
			continue
		}

		// Track import block end - ALWAYS KEEP IT
		if inImportBlock && trim == ")" {
			inImportBlock = false
			result = append(result, line)
			continue
		}

		// Inside import block - check if import should be kept
		if inImportBlock && trim != "" && !strings.HasPrefix(trim, "//") {
			// NEVER skip handlers import in test files - KEEP IT ALWAYS
			if strings.Contains(trim, "/internal/handlers\"") {
				result = append(result, line)
				continue
			}

			// Check for common unused imports
			shouldSkip := false

			// Skip unused bytes
			if strings.Contains(trim, `"bytes"`) && !strings.Contains(code, "bytes.") {
				shouldSkip = true
			}

			// Skip unused encoding/json
			if strings.Contains(trim, `"encoding/json"`) && !strings.Contains(code, "json.") {
				shouldSkip = true
			}

			// Skip unused models
			if strings.Contains(trim, "/internal/models\"") && !strings.Contains(code, "models.") {
				shouldSkip = true
			}

			// If not skipping, keep this import
			if !shouldSkip {
				result = append(result, line)
			}
			continue
		}

		// Not in import block - always keep
		result = append(result, line)
	}

	return strings.Join(result, "\n")
}

// parseImportLine extracts package name, alias, and full path from an import line
func parseImportLine(line string) struct{ pkg, alias, fullPath string } {
	result := struct{ pkg, alias, fullPath string }{}

	// Remove leading/trailing whitespace and quotes
	line = strings.TrimSpace(line)

	// Handle aliased imports: alias "path/to/package"
	if strings.Contains(line, " ") && strings.Contains(line, `"`) {
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			result.alias = parts[0]
			result.fullPath = strings.Trim(parts[1], `"`)
			result.pkg = getPackageNameFromPath(result.fullPath)
			return result
		}
	}

	// Handle regular imports: "path/to/package"
	if strings.Contains(line, `"`) {
		result.fullPath = strings.Trim(line, `"`)
		result.pkg = getPackageNameFromPath(result.fullPath)
		return result
	}

	return result
}

// getPackageNameFromPath extracts the package name from an import path
func getPackageNameFromPath(path string) string {
	// Remove quotes if present
	path = strings.Trim(path, `"`)

	// Get the last part of the path
	parts := strings.Split(path, "/")
	if len(parts) > 0 {
		lastPart := parts[len(parts)-1]
		// Handle versioned paths like v2, v3
		if strings.HasPrefix(lastPart, "v") && len(lastPart) > 1 {
			if len(parts) > 1 {
				return parts[len(parts)-2]
			}
		}
		return lastPart
	}

	return path
}

// isPackageUsed checks if a package name is actually used in the code
func isPackageUsed(code, pkgName string) bool {
	// Special cases: these are always considered "used"
	alwaysUsed := map[string]bool{
		"testing":  true,
		"net/http": true, // Even if only types are used
		"http":     true,
		"httptest": true,
	}

	if alwaysUsed[pkgName] {
		return true
	}

	// Check for package usage patterns:
	// 1. pkgName.Something (function/type calls)
	// 2. pkgName.CONSTANT (constants)
	// 3. &pkgName.Type{} (struct initialization)
	usagePatterns := []string{
		pkgName + ".",          // Most common: json.Marshal, models.Book, etc.
		"&" + pkgName + ".",    // Pointer: &models.Book{}
		"*" + pkgName + ".",    // Pointer type: *models.Book
		"[]" + pkgName + ".",   // Slice: []models.Book
		"[]*" + pkgName + ".",  // Slice of pointers: []*models.Book
		"map[" + pkgName + ".", // Map key
		"]" + pkgName + ".",    // Map value
	}

	for _, pattern := range usagePatterns {
		if strings.Contains(code, pattern) {
			return true
		}
	}

	return false
}
