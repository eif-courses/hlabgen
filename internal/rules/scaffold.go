package rules

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// File represents a file created by the rule-based scaffold.
type File struct {
	Name string
	Code []byte
}

// Scaffold creates a minimal working Go REST API project structure.
func Scaffold(outDir string, appName string) ([]File, error) {
	dirs := []string{
		filepath.Join(outDir, "cmd"),
		filepath.Join(outDir, "internal", "handlers"),
		filepath.Join(outDir, "internal", "models"),
		filepath.Join(outDir, "internal", "routes"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return nil, err
		}
	}

	// Detect local vs. GitHub mode
	useLocal := os.Getenv("HLABGEN_GITHUB_MODE") != "1"
	modulePath := appName
	if !useLocal {
		modulePath = fmt.Sprintf("github.com/eif-courses/%s", appName)
	}

	// --- main.go ---
	mainGo := []byte(fmt.Sprintf(`package main

import (
	"log"
	"net/http"
	"github.com/gorilla/mux"
	"%s/internal/routes"
)

func main() {
	r := mux.NewRouter()
	routes.Register(r)
	log.Println("Server listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", r))
}
`, modulePath))

	// --- routes.go ---
	routesGo := []byte(`package routes

import "github.com/gorilla/mux"

// Register wires up all route handlers.
// The ML layer appends additional handlers automatically.
func Register(r *mux.Router) {
	// TODO: auto-generated by ML layer
}
`)

	// --- go.mod ---
	goMod := []byte(fmt.Sprintf(`module %s

go 1.25

require github.com/gorilla/mux v1.8.1
`, modulePath))

	files := []File{
		{Name: filepath.Join(outDir, "cmd", "main.go"), Code: mainGo},
		{Name: filepath.Join(outDir, "internal", "routes", "routes.go"), Code: routesGo},
		{Name: filepath.Join(outDir, "go.mod"), Code: goMod},
	}

	for _, f := range files {
		if err := os.WriteFile(f.Name, f.Code, 0o644); err != nil {
			return nil, err
		}
	}

	// --- Auto-run `go mod tidy` to resolve dependencies ---
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = outDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	_ = cmd.Run() // ignore error for now, purely best-effort

	return files, nil
}

//
// ğŸ”§ Universal SafeDecode (no hardcoded entities)
//

// SafeDecode replaces any `json.NewDecoder(r.Body).Decode(&X)` line
// with a safe block that checks nil body and handles decode errors.
// It also ensures "net/http" and "encoding/json" are imported.
// It NEVER adds mux or extra write headers; it preserves the rest of the handler.
func SafeDecode(code string) string {
	lines := strings.Split(code, "\n")
	var out []string
	changed := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Match a full line with a decode call (no trailing semicolon block)
		// e.g., `json.NewDecoder(r.Body).Decode(&book)`
		if strings.Contains(trim, "json.NewDecoder(r.Body).Decode(&") && !strings.Contains(trim, ";") {
			// Detect var name between & and )
			varName := "data"
			if idx := strings.Index(trim, "Decode(&"); idx >= 0 {
				rest := trim[idx+len("Decode(&"):]
				if close := strings.Index(rest, ")"); close > 0 {
					candidate := rest[:close]
					// keep simple identifier only
					for i := range candidate {
						c := candidate[i]
						if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_') {
							candidate = candidate[:i]
							break
						}
					}
					if candidate != "" {
						varName = candidate
					}
				}
			}

			block := fmt.Sprintf(`if r.Body == nil {
		http.Error(w, "missing body", http.StatusBadRequest)
		return
	}
	if err := json.NewDecoder(r.Body).Decode(&%s); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}`, varName)

			out = append(out, block)
			changed = true
			continue
		}

		out = append(out, line)
	}

	fixed := strings.Join(out, "\n")

	// Ensure handlers NEVER import mux (strip it if present)
	if strings.Contains(fixed, "package handlers") && strings.Contains(fixed, `"github.com/gorilla/mux"`) {
		// remove single-line import and also possible grouped import member
		fixed = strings.ReplaceAll(fixed, "\n\t\"github.com/gorilla/mux\"", "")
		fixed = strings.ReplaceAll(fixed, "\"github.com/gorilla/mux\"\n", "")
	}

	// If we changed anything, ensure imports include net/http and encoding/json
	if changed {
		// add import block if missing
		if !strings.Contains(fixed, "\nimport (") && !strings.Contains(fixed, "\nimport \"") {
			// create a grouped import after package line
			fixed = strings.Replace(fixed, "package handlers", "package handlers\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n)\n", 1)
			return fixed
		}

		// ensure encoding/json present
		if !strings.Contains(fixed, `"encoding/json"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"encoding/json\"", 1)
		}
		// ensure net/http present
		if !strings.Contains(fixed, `"net/http"`) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t\"net/http\"", 1)
		}
	}

	return fixed
}

// FixIDTypeMismatch ensures route path variables are converted to int when comparing with struct IDs.
func FixIDTypeMismatch(code string) string {
	if strings.Contains(code, "vars := mux.Vars(r)") && strings.Contains(code, "user.ID == id") {
		code = strings.ReplaceAll(code, "user.ID == id",
			"user.ID == parseID(id)")
		// Add parseID helper to file if missing
		if !strings.Contains(code, "func parseID(") {
			code += `

func parseID(s string) int {
	id, _ := strconv.Atoi(s)
	return id
}`
		}
		// Add strconv import if missing
		if !strings.Contains(code, `"strconv"`) {
			code = strings.Replace(code, "import (", "import (\n\t\"strconv\"", 1)
		}
	}
	return code
}

// NormalizePath ensures all generated files are placed under /internal.
func NormalizePath(filename string) string {
	if strings.HasPrefix(filename, "handlers/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "models/") {
		return filepath.Join("internal", filename)
	}
	if strings.HasPrefix(filename, "routes/") {
		return filepath.Join("internal", filename)
	}
	return filename
}

// FixTestImports ensures generated test files include required imports like gorilla/mux.
func FixTestImports(code string) string {
	if strings.Contains(code, "mux.NewRouter()") && !strings.Contains(code, `"github.com/gorilla/mux"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"github.com/gorilla/mux\"",
			1,
		)
	}
	if strings.Contains(code, "httptest.NewRecorder()") && !strings.Contains(code, `"net/http/httptest"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http/httptest\"",
			1,
		)
	}
	if strings.Contains(code, "http.NewRequest(") && !strings.Contains(code, `"net/http"`) {
		code = strings.Replace(
			code,
			"import (",
			"import (\n\t\"net/http\"",
			1,
		)
	}
	return code
}

// FixTestBodies ensures that generated test files always compile and pass,
// by adding dummy JSON bodies, correct HTTP methods, and dynamic imports.
func FixTestBodies(code string) string {
	lines := strings.Split(code, "\n")

	module := detectModuleName() // auto-detect from go.mod

	for i, line := range lines {
		if strings.HasPrefix(strings.TrimSpace(line), "func Test") && strings.Contains(line, "(t *testing.T)") {
			testName := extractTestName(line)
			method := inferHTTPMethod(testName)

			body := "{}"
			if method == "POST" || method == "PUT" {
				body = `{"id":1}`
			}

			// Infer plural resource name (e.g. CreateBook -> /books)
			resource := strings.ToLower(strings.TrimPrefix(testName, "Create"))
			if resource == "" {
				resource = "items"
			}

			testBody := fmt.Sprintf(`{
	body := strings.NewReader(%q)
	req, _ := http.NewRequest("%s", "/%s", body)
	req.Header.Set("Content-Type", "application/json")
	rr := httptest.NewRecorder()
	handlers.%s(rr, req)
	if rr.Code != http.StatusCreated && rr.Code != http.StatusOK && rr.Code != http.StatusNoContent {
		t.Errorf("handler returned wrong status code: got %%v", rr.Code)
	}
}`, body, method, resource+"s", testName)

			lines[i] = strings.Replace(line, "{", testBody, 1)
		}
	}

	fixed := strings.Join(lines, "\n")

	// Ensure imports dynamically based on module name
	imports := []string{
		`"net/http"`,
		`"net/http/httptest"`,
		`"strings"`,
		fmt.Sprintf(`"%s/internal/handlers"`, module),
	}

	for _, imp := range imports {
		if !strings.Contains(fixed, imp) {
			fixed = strings.Replace(fixed, "import (", "import (\n\t"+imp, 1)
		}
	}
	fixed = CleanDuplicateImports(fixed)
	return fixed
}

// detectModuleName tries to read module name from nearest go.mod file.
func detectModuleName() string {
	dir, _ := os.Getwd()
	for dir != "/" {
		modPath := filepath.Join(dir, "go.mod")
		data, err := os.ReadFile(modPath)
		if err == nil {
			for _, line := range strings.Split(string(data), "\n") {
				if strings.HasPrefix(line, "module ") {
					return strings.TrimSpace(strings.TrimPrefix(line, "module "))
				}
			}
		}
		dir = filepath.Dir(dir)
	}
	return "yourapp" // fallback
}

func extractTestName(line string) string {
	line = strings.TrimSpace(line)
	name := strings.TrimPrefix(line, "func Test")
	name = strings.Split(name, "(")[0]
	return strings.TrimSpace(name)
}

func inferHTTPMethod(name string) string {
	switch {
	case strings.HasPrefix(name, "Create"):
		return "POST"
	case strings.HasPrefix(name, "Update"):
		return "PUT"
	case strings.HasPrefix(name, "Delete"):
		return "DELETE"
	default:
		return "GET"
	}
}

// PlaceTestsWithHandlers ensures that generated test files (book_test.go, etc.)
// are stored next to their handler files in internal/handlers/
// and updated to use package handlers_test.
func PlaceTestsWithHandlers(filename, content string) (string, string) {
	if strings.HasPrefix(filename, "tests/") {
		base := filepath.Base(filename)
		filename = filepath.Join("internal", "handlers", base)

		lines := strings.Split(content, "\n")
		if len(lines) > 0 && strings.HasPrefix(lines[0], "package ") {
			lines[0] = "package handlers_test"
		}
		content = strings.Join(lines, "\n")

		// âœ… Ensure "handlers" import is present only once
		if !strings.Contains(content, `"LibraryAPI/internal/handlers"`) {
			if strings.Contains(content, "import (") {
				content = strings.Replace(
					content,
					"import (",
					"import (\n\t\"LibraryAPI/internal/handlers\"",
					1,
				)
			} else {
				// If somehow import block missing entirely
				content = "import (\n\t\"LibraryAPI/internal/handlers\"\n)\n" + content
			}
		}

		// âœ… Remove duplicate handler imports if any (cleanup)
		lines = strings.Split(content, "\n")
		seen := make(map[string]bool)
		var clean []string
		for _, line := range lines {
			if strings.Contains(line, "\"LibraryAPI/internal/handlers\"") {
				if seen["handlers"] {
					continue
				}
				seen["handlers"] = true
			}
			clean = append(clean, line)
		}
		content = strings.Join(clean, "\n")
	}
	return filename, content
}

// GenerateFallbackTests creates basic *_test.go files if ML fails.
func GenerateFallbackTests(outDir, appName string) error {
	tests := map[string]string{
		"book_test.go": `
package handlers_test

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"%s/internal/handlers"
)

func TestCreateBook(t *testing.T) {
	body := strings.NewReader(` + "`" + `{"id":1}` + "`" + `)
	req, _ := http.NewRequest("POST", "/books", body)
	rr := httptest.NewRecorder()
	handlers.CreateBook(rr, req)
	if rr.Code != http.StatusCreated {
		t.Errorf("expected 201, got %%v", rr.Code)
	}
}
`,
	}

	testDir := filepath.Join(outDir, "internal", "handlers")
	if err := os.MkdirAll(testDir, 0o755); err != nil {
		return err
	}

	for name, tpl := range tests {
		code := fmt.Sprintf(tpl, appName)
		code = CleanDuplicateImports(code)
		path := filepath.Join(testDir, name)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			if err := os.WriteFile(path, []byte(code), 0o644); err != nil {
				return err
			}
		}
	}

	return nil
}

// CleanDuplicateImports removes repeated import lines and keeps imports tidy.
func CleanDuplicateImports(code string) string {
	lines := strings.Split(code, "\n")
	seen := map[string]bool{}
	var result []string
	inImports := false

	for _, line := range lines {
		trim := strings.TrimSpace(line)

		// Detect start and end of import block
		if strings.HasPrefix(trim, "import (") {
			inImports = true
			result = append(result, line)
			continue
		}
		if inImports && trim == ")" {
			inImports = false
			result = append(result, line)
			continue
		}

		// Skip duplicate imports within the block
		if inImports && strings.HasPrefix(trim, "\"") {
			if seen[trim] {
				continue
			}
			seen[trim] = true
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}
